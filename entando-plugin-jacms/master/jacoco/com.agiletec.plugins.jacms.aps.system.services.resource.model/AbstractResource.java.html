<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractResource.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Entando Plugin: CMS</a> &gt; <a href="index.source.html" class="el_package">com.agiletec.plugins.jacms.aps.system.services.resource.model</a> &gt; <span class="el_source">AbstractResource.java</span></div><h1>AbstractResource.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2015-Present Entando Inc. (http://www.entando.com) All rights reserved.
 *
 * This library is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation; either version 2.1 of the License, or (at your option)
 * any later version.
 *
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 */
package com.agiletec.plugins.jacms.aps.system.services.resource.model;

import com.agiletec.aps.system.exception.ApsSystemException;
import com.agiletec.aps.system.services.category.Category;
import com.agiletec.aps.system.services.group.Group;
import com.agiletec.plugins.jacms.aps.system.services.resource.parse.ResourceDOM;
import org.apache.commons.io.FilenameUtils;
import org.entando.entando.aps.system.services.storage.IStorageManager;
import org.slf4j.*;
import org.springframework.util.Assert;

import java.io.*;
import java.util.*;

public abstract class AbstractResource implements ResourceInterface, Serializable {

<span class="fc" id="L30">    private static final Logger logger = LoggerFactory.getLogger(AbstractResource.class);</span>

    private String id;
    private String typeCode;
    private String description;
    private String mainGroup;
    private String masterFileName;
    private List&lt;Category&gt; categories;
    private String folder;
    private String protectedBaseURL;
    private String owner;
    private String folderPath;

    private String allowedExtensions;

    private Date creationDate;
    private Date lastModified;

    private IStorageManager storageManager;
    private Map&lt;String, String&gt; metadata;

    private String metadataIgnoreKeys;
    
    /**
     * Inizializza gli elementi base costituenti la Risorsa.
     */
<span class="fc" id="L56">    public AbstractResource() {</span>
<span class="fc" id="L57">        this.setId(&quot;&quot;);</span>
<span class="fc" id="L58">        this.setType(&quot;&quot;);</span>
<span class="fc" id="L59">        this.setDescription(&quot;&quot;);</span>
<span class="fc" id="L60">        this.setMainGroup(&quot;&quot;);</span>
<span class="fc" id="L61">        this.setMasterFileName(&quot;&quot;);</span>
<span class="fc" id="L62">        this.categories = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L63">        this.setFolder(&quot;&quot;);</span>
<span class="fc" id="L64">        this.setCreationDate(null);</span>
<span class="fc" id="L65">        this.setMetadata(new HashMap&lt;&gt;());</span>
<span class="fc" id="L66">        this.setLastModified(null);</span>
<span class="fc" id="L67">        this.setOwner(null);</span>
<span class="fc" id="L68">        this.setFolderPath(null);</span>
<span class="fc" id="L69">    }</span>

    /**
     * Restituisce l'identificativo della risorsa.
     *
     * @return L'identificativo della risorsa.
     */
    @Override
    public String getId() {
<span class="fc" id="L78">        return id;</span>
    }

    /**
     * Setta l'identificativo della risorsa.
     *
     * @param id L'identificativo della risorsa.
     */
    @Override
    public void setId(String id) {
<span class="fc" id="L88">        this.id = id;</span>
<span class="fc" id="L89">    }</span>

    /**
     * Restituisce il codice del tipo di risorsa.
     *
     * @return Il codice del tipo di risorsa.
     */
    @Override
    public String getType() {
<span class="fc" id="L98">        return typeCode;</span>
    }

    /**
     * Setta il codice del tipo di risorsa.
     *
     * @param typeCode Il codice del tipo di risorsa.
     */
    @Override
    public void setType(String typeCode) {
<span class="fc" id="L108">        this.typeCode = typeCode;</span>
<span class="fc" id="L109">    }</span>

    /**
     * @deprecated use getDescription method
     */
    @Override
    @Deprecated
    public String getDescr() {
<span class="nc" id="L117">        return this.getDescription();</span>
    }

    /**
     * @deprecated use setDescription method
     */
    @Override
    @Deprecated
    public void setDescr(String descr) {
<span class="fc" id="L126">        this.setDescription(descr);</span>
<span class="fc" id="L127">    }</span>

    @Override
    public String getDescription() {
<span class="fc" id="L131">        return description;</span>
    }

    @Override
    public void setDescription(String description) {
<span class="fc" id="L136">        this.description = description;</span>
<span class="fc" id="L137">    }</span>

    /**
     * Restituisce la stringa identificante il gruppo principale di cui la
     * risorsa è membro.
     *
     * @return Il gruppo principale di cui la risorsa è membro.
     */
    @Override
    public String getMainGroup() {
<span class="fc" id="L147">        return mainGroup;</span>
    }

    /**
     * Setta la stringa identificante il gruppo principale di cui il contenuto è
     * membro.
     *
     * @param mainGroup Il gruppo principale di cui il contenuto è membro.
     */
    @Override
    public void setMainGroup(String mainGroup) {
<span class="fc" id="L158">        this.mainGroup = mainGroup;</span>
<span class="fc" id="L159">    }</span>

    @Override
    public String getMasterFileName() {
<span class="fc" id="L163">        return masterFileName;</span>
    }

    @Override
    public void setMasterFileName(String masterFileName) {
<span class="fc" id="L168">        this.masterFileName = masterFileName;</span>
<span class="fc" id="L169">    }</span>

    @Override
    public Date getCreationDate() {
<span class="fc" id="L173">        return creationDate;</span>
    }

    @Override
    public void setCreationDate(Date creationDate) {
<span class="fc" id="L178">        this.creationDate = creationDate;</span>
<span class="fc" id="L179">    }</span>

    @Override
    public Date getLastModified() {
<span class="fc" id="L183">        return lastModified;</span>
    }

    @Override
    public void setLastModified(Date lastModified) {
<span class="fc" id="L188">        this.lastModified = lastModified;</span>
<span class="fc" id="L189">    }</span>

    /**
     * Aggiunge una categoria alla lista delle categorie della risorsa.
     *
     * @param category La categoria da aggiungere.
     */
    @Override
    public void addCategory(Category category) {
<span class="fc" id="L198">        this.categories.add(category);</span>
<span class="fc" id="L199">    }</span>

    /**
     * Restituisce la lista di categorie associate alla risorsa.
     *
     * @return La lista di categorie associate alla risorsa.
     */
    @Override
    public List&lt;Category&gt; getCategories() {
<span class="fc" id="L208">        return categories;</span>
    }

    /**
     * Setta la lista di categorie associate alla risorsa.
     *
     * @param categories La lista di categorie associate alla risorsa.
     */
    @Override
    public void setCategories(List&lt;Category&gt; categories) {
<span class="fc" id="L218">        this.categories = categories;</span>
<span class="fc" id="L219">    }</span>

    /**
     * Rimuove una categoria alla lista delle categorie della risorsa.
     *
     * @param category La categoria da rimuovere.
     */
    public void removeCategory(Category category) {
<span class="nc" id="L227">        this.categories.remove(category);</span>
<span class="nc" id="L228">    }</span>

    /**
     * Restituisce il nome della cartella contenitore delle risorse.
     *
     * @return Il nome della cartella contenitore delle risorse.
     */
    @Override
    public String getFolder() {
<span class="fc" id="L237">        return folder;</span>
    }

    /**
     * Setta il nome della cartella contenitore delle risorse.
     *
     * @param folder Il nome della cartella contenitore delle risorse.
     */
    @Override
    public void setFolder(String folder) {
<span class="fc bfc" id="L247" title="All 2 branches covered.">        if (!folder.endsWith(&quot;/&quot;)) {</span>
<span class="fc" id="L248">            folder += &quot;/&quot;;</span>
        }
<span class="fc" id="L250">        this.folder = folder;</span>
<span class="fc" id="L251">    }</span>

    /**
     * Restituisce l'url base della cartella delle risorse pretette.
     *
     * @return L'url base della cartella delle risorse protette.
     */
    protected String getProtectedBaseURL() {
<span class="fc" id="L259">        return protectedBaseURL;</span>
    }

    public void setProtectedBaseURL(String protBaseURL) {
<span class="fc" id="L263">        this.protectedBaseURL = protBaseURL;</span>
<span class="fc" id="L264">    }</span>

    @Override
    public String[] getAllowedFileTypes() {
<span class="fc" id="L268">        return this.getAllowedExtensions().split(&quot;,&quot;);</span>
    }

    /**
     * Setta la stringa rappresentante l'insieme delle estensioni consentite
     * separate da virgola.
     *
     * @return L'insieme delle estensioni consentite.
     */
    protected String getAllowedExtensions() {
<span class="fc" id="L278">        return allowedExtensions;</span>
    }

    /**
     * Setta la stringa rappresentante l'insieme delle estensioni consentite
     * separate da virgola.
     *
     * @param allowedExtensions L'insieme delle estensioni consentite.
     */
    public void setAllowedExtensions(String allowedExtensions) {
<span class="fc" id="L288">        this.allowedExtensions = allowedExtensions;</span>
<span class="fc" id="L289">    }</span>

    @Override
    public Map&lt;String, String&gt; getMetadata() {
<span class="fc" id="L293">        return metadata;</span>
    }

    @Override
    public void setMetadata(Map&lt;String, String&gt; metadata) {
<span class="fc" id="L298">        this.metadata = metadata;</span>
<span class="fc" id="L299">    }</span>

    @Override
    public ResourceInterface getResourcePrototype() {
        AbstractResource prototype;
        try {
<span class="fc" id="L305">            Class resourceClass = Class.forName(this.getClass().getName());</span>
<span class="fc" id="L306">            prototype = (AbstractResource) resourceClass.newInstance();</span>
<span class="nc" id="L307">        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException t) {</span>
<span class="nc" id="L308">            throw new RuntimeException(&quot;Error in creation of prototype of resource type&quot;</span>
                    + &quot; '&quot; + typeCode + &quot;'&quot;, t);
<span class="fc" id="L310">        }</span>
<span class="fc" id="L311">        prototype.setId(&quot;&quot;);</span>
<span class="fc" id="L312">        prototype.setType(typeCode);</span>
<span class="fc" id="L313">        prototype.setDescription(&quot;&quot;);</span>
<span class="fc" id="L314">        prototype.setMainGroup(&quot;&quot;);</span>
<span class="fc" id="L315">        prototype.setMasterFileName(&quot;&quot;);</span>
<span class="fc" id="L316">        prototype.setCategories(new ArrayList&lt;&gt;());</span>
<span class="fc" id="L317">        prototype.setFolder(folder);</span>
<span class="fc" id="L318">        prototype.setProtectedBaseURL(protectedBaseURL);</span>
<span class="fc" id="L319">        prototype.setAllowedExtensions(allowedExtensions);</span>
<span class="fc" id="L320">        prototype.setStorageManager(storageManager);</span>
<span class="fc" id="L321">        prototype.setCreationDate(null);</span>
<span class="fc" id="L322">        prototype.setLastModified(null);</span>
<span class="fc" id="L323">        prototype.setMetadata(new HashMap&lt;&gt;());</span>
<span class="fc" id="L324">        prototype.setMetadataIgnoreKeys(metadataIgnoreKeys);</span>
<span class="fc" id="L325">        return prototype;</span>
    }

    /**
     * Restituisce la classe dom (necessaria per la generazione dell'xml della
     * risorsa) preparata con gli attributi base della risorsa.
     *
     * @return La classe dom preparata con gli attributi base della risorsa.
     */
    protected ResourceDOM getResourceDOM() {
<span class="fc" id="L335">        ResourceDOM resourceDom = this.getNewResourceDOM();</span>
<span class="fc" id="L336">        resourceDom.setTypeCode(typeCode);</span>
<span class="fc" id="L337">        resourceDom.setId(id);</span>
<span class="fc" id="L338">        resourceDom.setDescription(description);</span>
<span class="fc" id="L339">        resourceDom.setMainGroup(mainGroup);</span>
<span class="fc" id="L340">        resourceDom.setMasterFileName(masterFileName);</span>
<span class="pc bpc" id="L341" title="1 of 2 branches missed.">        if (categories != null) {</span>
<span class="fc bfc" id="L342" title="All 2 branches covered.">            for (Category cat : categories) {</span>
<span class="fc" id="L343">                resourceDom.addCategory(cat.getCode());</span>
<span class="fc" id="L344">            }</span>
        }
<span class="fc" id="L346">        return resourceDom;</span>
    }

    protected ResourceDOM getNewResourceDOM() {
<span class="fc" id="L350">        return new ResourceDOM();</span>
    }

    protected String getDiskSubFolder() {
<span class="fc" id="L354">        StringBuilder diskFolder = new StringBuilder(folder);</span>
<span class="fc bfc" id="L355" title="All 2 branches covered.">        if (this.isProtectedResource()) {</span>
<span class="fc" id="L356">            diskFolder.append(mainGroup).append(&quot;/&quot;);</span>
        }
<span class="fc" id="L358">        return diskFolder.toString();</span>
    }

    @Override
    public InputStream getResourceStream(ResourceInstance instance) {
<span class="nc" id="L363">        return this.getResourceStream(instance.getSize(), instance.getLangCode());</span>
    }

    @Override
    public String getDefaultUrlPath() {
<span class="fc" id="L368">        ResourceInstance defaultInstance = this.getDefaultInstance();</span>
<span class="fc" id="L369">        return this.getUrlPath(defaultInstance);</span>
    }

    /**
     * Repurn the url path of the given istance.
     *
     * @param instance the resource instance
     * @return Il path del file relativo all'istanza.
     */
    protected String getUrlPath(ResourceInstance instance) {
<span class="pc bpc" id="L379" title="1 of 2 branches missed.">        if (instance == null) {</span>
<span class="nc" id="L380">            return null;</span>
        }
<span class="fc" id="L382">        StringBuilder urlPath = new StringBuilder();</span>
<span class="fc bfc" id="L383" title="All 2 branches covered.">        if (this.isProtectedResource()) {</span>
            //PATH di richiamo della servlet di autorizzazione
            //Sintassi /&lt;RES_ID&gt;/&lt;SIZE&gt;/&lt;LANG_CODE&gt;/
<span class="fc" id="L386">            final String def = &quot;def&quot;;</span>
<span class="fc" id="L387">            urlPath.append(this.getProtectedBaseURL());</span>
<span class="pc bpc" id="L388" title="1 of 2 branches missed.">            if (!urlPath.toString().endsWith(&quot;/&quot;)) {</span>
<span class="nc" id="L389">                urlPath.append(&quot;/&quot;);</span>
            }
<span class="fc" id="L391">            urlPath.append(this.getId()).append(&quot;/&quot;);</span>
<span class="pc bpc" id="L392" title="1 of 2 branches missed.">            if (instance.getSize() &lt; 0) {</span>
<span class="nc" id="L393">                urlPath.append(def);</span>
            } else {
<span class="fc" id="L395">                urlPath.append(instance.getSize());</span>
            }
<span class="fc" id="L397">            urlPath.append(&quot;/&quot;);</span>
<span class="pc bpc" id="L398" title="1 of 2 branches missed.">            if (instance.getLangCode() == null) {</span>
<span class="fc" id="L399">                urlPath.append(def);</span>
            } else {
<span class="nc" id="L401">                urlPath.append(instance.getLangCode());</span>
            }
<span class="fc" id="L403">            urlPath.append(&quot;/&quot;);</span>
<span class="fc" id="L404">        } else {</span>
<span class="fc" id="L405">            StringBuilder subFolder = new StringBuilder(this.getFolder());</span>
<span class="pc bpc" id="L406" title="1 of 2 branches missed.">            if (!subFolder.toString().endsWith(&quot;/&quot;)) {</span>
<span class="nc" id="L407">                subFolder.append(&quot;/&quot;);</span>
            }
<span class="fc" id="L409">            subFolder.append(instance.getFileName());</span>
<span class="fc" id="L410">            String path = this.getStorageManager().getResourceUrl(subFolder.toString(), false);</span>
<span class="fc" id="L411">            urlPath.append(path);</span>
        }
<span class="fc" id="L413">        return urlPath.toString();</span>
    }

    protected boolean isProtectedResource() {
<span class="fc bfc" id="L417" title="All 2 branches covered.">        return (!Group.FREE_GROUP_NAME.equals(this.getMainGroup()));</span>
    }

    protected File saveTempFile(String filename, InputStream is) throws ApsSystemException, IOException {
<span class="fc" id="L421">        String tempDir = System.getProperty(&quot;java.io.tmpdir&quot;);</span>
<span class="fc" id="L422">        String filePath = tempDir + File.separator + filename;</span>
<span class="fc" id="L423">        FileOutputStream outStream = null;</span>
        try {
<span class="fc" id="L425">            byte[] buffer = new byte[1024];</span>
            int length;
<span class="fc" id="L427">            outStream = new FileOutputStream(filePath);</span>
<span class="fc bfc" id="L428" title="All 2 branches covered.">            while ((length = is.read(buffer)) != -1) {</span>
<span class="fc" id="L429">                outStream.write(buffer, 0, length);</span>
<span class="fc" id="L430">                outStream.flush();</span>
            }
<span class="nc" id="L432">        } catch (Throwable t) {</span>
<span class="nc" id="L433">            logger.error(&quot;Error on saving temporary file '{}'&quot;, filename, t);</span>
<span class="nc" id="L434">            throw new ApsSystemException(&quot;Error on saving temporary file&quot;, t);</span>
        } finally {
<span class="pc bpc" id="L436" title="1 of 2 branches missed.">            if (null != outStream) {</span>
<span class="fc" id="L437">                outStream.close();</span>
            }
<span class="pc bpc" id="L439" title="1 of 2 branches missed.">            if (null != is) {</span>
<span class="fc" id="L440">                is.close();</span>
            }
        }
<span class="fc" id="L443">        return new File(filePath);</span>
    }
    
    protected String getUniqueBaseName(String originalFileName) {
<span class="fc" id="L447">        Assert.hasLength(originalFileName, &quot;File name must not be null or empty&quot;);</span>
<span class="fc" id="L448">        String baseName = FilenameUtils.getBaseName(originalFileName);</span>
<span class="fc" id="L449">        String extension = FilenameUtils.getExtension(originalFileName);</span>
<span class="fc" id="L450">        baseName = this.purgeBaseName(baseName);</span>
<span class="fc" id="L451">        String suggestedName = baseName;</span>
<span class="fc" id="L452">        int fileOrder = 1;</span>
<span class="fc bfc" id="L453" title="All 2 branches covered.">        while(this.exists(this.createFileName(suggestedName, extension))) {</span>
<span class="fc" id="L454">            suggestedName = baseName + '_' + fileOrder;</span>
<span class="fc" id="L455">            fileOrder ++;</span>
        }
<span class="fc" id="L457">        return suggestedName;</span>
    }

    protected String getMultiFileUniqueBaseName(String baseName, String suffix, String extension) {
<span class="fc" id="L461">        Assert.hasLength(baseName, &quot;base name of file can't be null or empty&quot;);</span>
<span class="fc" id="L462">        Assert.notNull(suffix, &quot;file suffix can't be null&quot;);</span>
<span class="fc" id="L463">        baseName = this.purgeBaseName(baseName);</span>
<span class="fc" id="L464">        String suggestedName = baseName + suffix;</span>
<span class="fc" id="L465">        int fileOrder = 1;</span>
<span class="fc bfc" id="L466" title="All 2 branches covered.">        while(this.exists(this.createFileName(suggestedName, extension))) {</span>
<span class="fc" id="L467">            suggestedName = baseName + '_' + fileOrder + suffix;</span>
<span class="fc" id="L468">            fileOrder ++;</span>
        }
<span class="fc" id="L470">        return suggestedName;</span>
    }
    
    private String purgeBaseName(String baseName) {
<span class="fc" id="L474">        String purgedName = baseName.replaceAll(&quot;[^ _.a-zA-Z0-9]&quot;, &quot;&quot;);</span>
<span class="fc" id="L475">        return purgedName.trim().replace(' ', '_');</span>
    }

    protected String createFileName(String baseName, String extension) {
<span class="pc bpc" id="L479" title="1 of 2 branches missed.">        return extension == null ? baseName : baseName + '.' + extension;</span>
    }

    protected boolean exists(String instanceFileName) {
        try {
<span class="fc" id="L484">            String subPath = this.getDiskSubFolder() + instanceFileName;</span>
<span class="fc" id="L485">            return this.getStorageManager().exists(subPath, this.isProtectedResource());</span>
<span class="nc" id="L486">        } catch (Throwable t) {</span>
<span class="nc" id="L487">            logger.error(&quot;Error testing existing file '{}'&quot;, instanceFileName, t);</span>
<span class="nc" id="L488">            throw new RuntimeException(&quot;Error testing existing file&quot;, t);</span>
        }
    }

    protected IStorageManager getStorageManager() {
<span class="fc" id="L493">        return storageManager;</span>
    }

    public void setStorageManager(IStorageManager storageManager) {
<span class="fc" id="L497">        this.storageManager = storageManager;</span>
<span class="fc" id="L498">    }</span>

    @Override
    public String getMetadataIgnoreKeys() {
<span class="fc" id="L502">        return metadataIgnoreKeys;</span>
    }

    @Override
    public void setMetadataIgnoreKeys(String metadataIgnoreKeys) {
<span class="fc" id="L507">        this.metadataIgnoreKeys = metadataIgnoreKeys;</span>
<span class="fc" id="L508">    }</span>

    @Override
    public String getOwner() {
<span class="fc" id="L512">        return owner;</span>
    }

    @Override
    public void setOwner(String owner) {
<span class="fc" id="L517">        this.owner = owner;</span>
<span class="fc" id="L518">    }</span>

    @Override
    public String getFolderPath() {
<span class="fc" id="L522">        return folderPath;</span>
    }

    @Override
    public void setFolderPath(String folderPath) {
<span class="fc" id="L527">        this.folderPath = folderPath;</span>
<span class="fc" id="L528">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>