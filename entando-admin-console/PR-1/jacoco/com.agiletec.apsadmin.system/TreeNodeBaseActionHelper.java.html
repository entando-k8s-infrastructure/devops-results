<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TreeNodeBaseActionHelper.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Entando Core: Administration Console</a> &gt; <a href="index.source.html" class="el_package">com.agiletec.apsadmin.system</a> &gt; <span class="el_source">TreeNodeBaseActionHelper.java</span></div><h1>TreeNodeBaseActionHelper.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2015-Present Entando Inc. (http://www.entando.com) All rights reserved.
 *
 * This library is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation; either version 2.1 of the License, or (at your option)
 * any later version.
 *
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 */
package com.agiletec.apsadmin.system;

import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.agiletec.aps.system.common.tree.ITreeNode;
import com.agiletec.aps.system.common.tree.ITreeNodeManager;
import com.agiletec.aps.system.exception.ApsSystemException;

/**
 * Classe base per gli helper che gestiscono le operazioni su oggetti alberi.
 *
 * @author E.Santoboni
 */
<span class="fc" id="L33">public abstract class TreeNodeBaseActionHelper extends BaseActionHelper implements ITreeNodeBaseActionHelper {</span>

<span class="fc" id="L35">	private static final Logger _logger = LoggerFactory.getLogger(TreeNodeBaseActionHelper.class);</span>

	/**
	 * Costruisce il codice univoco di un nodo in base ai parametri specificato.
	 * Il metodo: 1) elimina i caratteri non compresi tra &quot;a&quot; e &quot;z&quot;, tra &quot;0&quot; e
	 * &quot;9&quot;. 2) taglia (se necessario) la stringa secondo la lunghezza massima
	 * immessa. 3) verifica se esistono entit√† con il codice ricavato (ed in tal
	 * caso appende il suffisso &quot;_&lt;numero&gt;&quot; fino a che non trova un codice
	 * univoco).
	 *
	 * @param title Il titolo del nuovo nodo.
	 * @param baseDefaultCode Un codice nodo di default.
	 * @param maxLength La lunghezza massima del codice.
	 * @return Il codice univoco univoco ricavato.
	 * @throws ApsSystemException In caso di errore.
	 */
	@Override
	public String buildCode(String title, String baseDefaultCode, int maxLength) throws ApsSystemException {
<span class="nc" id="L53">		String uniqueCode = null;</span>
		try {
			// punto 1
<span class="nc bnc" id="L56" title="All 2 branches missed.">			uniqueCode = (null != title) ? purgeString(title) : baseDefaultCode;</span>
<span class="nc bnc" id="L57" title="All 2 branches missed.">			if (uniqueCode.length() == 0) {</span>
<span class="nc" id="L58">				uniqueCode = baseDefaultCode;</span>
			}
			// punto 2
<span class="nc bnc" id="L61" title="All 2 branches missed.">			if (uniqueCode.length() &gt; maxLength) {</span>
<span class="nc" id="L62">				uniqueCode = uniqueCode.substring(0, maxLength);</span>
<span class="nc bnc" id="L63" title="All 2 branches missed.">				if (uniqueCode.charAt(uniqueCode.length() - 1) == '_') {</span>
<span class="nc" id="L64">					uniqueCode = uniqueCode.substring(0, uniqueCode.length() - 1);</span>
				}
			}
			//punto 3
<span class="nc bnc" id="L68" title="All 2 branches missed.">			if (null != this.getTreeNode(uniqueCode)) {</span>
<span class="nc" id="L69">				int index = 0;</span>
<span class="nc" id="L70">				String currentCode = null;</span>
				do {
<span class="nc" id="L72">					index++;</span>
<span class="nc" id="L73">					currentCode = uniqueCode + &quot;_&quot; + index;</span>
<span class="nc bnc" id="L74" title="All 2 branches missed.">				} while (null != this.getTreeNode(currentCode));</span>
<span class="nc" id="L75">				uniqueCode = currentCode;</span>
			}
<span class="nc" id="L77">		} catch (Throwable t) {</span>
<span class="nc" id="L78">			throw new ApsSystemException(&quot;Errore in creazione nuovo codice&quot;, t);</span>
<span class="nc" id="L79">		}</span>
<span class="nc" id="L80">		return uniqueCode;</span>
	}

	@Override
	public Set&lt;String&gt; checkTargetNodes(String nodeToOpen, Set&lt;String&gt; lastOpenedNodes, Collection&lt;String&gt; groupCodes) throws ApsSystemException {
<span class="nc" id="L85">		Set&lt;String&gt; checkedTargetNodes = new HashSet&lt;&gt;();</span>
		try {
<span class="nc bnc" id="L87" title="All 4 branches missed.">			if (null != nodeToOpen &amp;&amp; this.checkNode(nodeToOpen, groupCodes)) {</span>
<span class="nc" id="L88">				checkedTargetNodes.add(nodeToOpen);</span>
			}
<span class="nc bnc" id="L90" title="All 2 branches missed.">			if (null != lastOpenedNodes) {</span>
<span class="nc" id="L91">				Iterator&lt;String&gt; iter = lastOpenedNodes.iterator();</span>
<span class="nc bnc" id="L92" title="All 2 branches missed.">				while (iter.hasNext()) {</span>
<span class="nc" id="L93">					String code = (String) iter.next();</span>
<span class="nc bnc" id="L94" title="All 4 branches missed.">					if (null != code &amp;&amp; this.checkNode(code, groupCodes)) {</span>
<span class="nc" id="L95">						checkedTargetNodes.add(code);</span>
					}
<span class="nc" id="L97">				}</span>
			}
<span class="nc" id="L99">		} catch (Throwable t) {</span>
<span class="nc" id="L100">			_logger.error(&quot;Error check target nodes&quot;, t);</span>
<span class="nc" id="L101">			throw new ApsSystemException(&quot;Error check target nodes&quot;, t);</span>
<span class="nc" id="L102">		}</span>
<span class="nc" id="L103">		return checkedTargetNodes;</span>
	}

	@Override
	public Set&lt;String&gt; checkTargetNodesOnClosing(String nodeToCloseCode, Set&lt;String&gt; lastOpenedNodes, Collection&lt;String&gt; groupCodes) throws ApsSystemException {
<span class="nc" id="L108">		ITreeNode nodeToClose = this.getTreeNode(nodeToCloseCode);</span>
<span class="nc bnc" id="L109" title="All 4 branches missed.">		if (null == nodeToCloseCode || null == nodeToClose) {</span>
<span class="nc" id="L110">			return this.checkTargetNodes(null, lastOpenedNodes, groupCodes);</span>
		}
<span class="nc" id="L112">		Set&lt;String&gt; checkedTargetNodes = new HashSet&lt;&gt;();</span>
		try {
<span class="nc bnc" id="L114" title="All 2 branches missed.">			if (nodeToClose.isRoot()) {</span>
<span class="nc" id="L115">				return checkedTargetNodes;</span>
			}
<span class="nc bnc" id="L117" title="All 2 branches missed.">			if (null != lastOpenedNodes) {</span>
<span class="nc" id="L118">				Iterator&lt;String&gt; iter = lastOpenedNodes.iterator();</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">				while (iter.hasNext()) {</span>
<span class="nc" id="L120">					String code = (String) iter.next();</span>
<span class="nc bnc" id="L121" title="All 4 branches missed.">					if (null != code &amp;&amp; this.checkNode(code, groupCodes)</span>
<span class="nc bnc" id="L122" title="All 4 branches missed.">							&amp;&amp; !code.equals(nodeToCloseCode) &amp;&amp; !this.getTreeNode(code).isChildOf(nodeToCloseCode, this.getTreeNodeManager())) {</span>
<span class="nc" id="L123">						checkedTargetNodes.add(code);</span>
					}
<span class="nc" id="L125">				}</span>
			}
<span class="nc bnc" id="L127" title="All 2 branches missed.">			if (null != nodeToClose.getParentCode()</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">					&amp;&amp; this.checkNode(nodeToClose.getParentCode(), groupCodes)) {</span>
<span class="nc" id="L129">				checkedTargetNodes.add(nodeToClose.getParentCode());</span>
			}
<span class="nc" id="L131">		} catch (Throwable t) {</span>
<span class="nc" id="L132">			_logger.error(&quot;Error check target nodes on closing tree&quot;, t);</span>
<span class="nc" id="L133">			throw new ApsSystemException(&quot;Error check target nodes on closing tree&quot;, t);</span>
<span class="nc" id="L134">		}</span>
<span class="nc" id="L135">		return checkedTargetNodes;</span>
	}

	protected boolean checkNode(String nodeCode, Collection&lt;String&gt; groupCodes) {
<span class="nc bnc" id="L139" title="All 2 branches missed.">		if (!this.isNodeAllowed(nodeCode, groupCodes)) {</span>
<span class="nc" id="L140">			_logger.error(&quot;Node '{}' not allowed &quot;, nodeCode);</span>
<span class="nc" id="L141">			return false;</span>
		}
<span class="nc" id="L143">		ITreeNode treeNode = this.getTreeNode(nodeCode);</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">		if (null == treeNode) {</span>
<span class="nc" id="L145">			_logger.error(&quot;Node '{}' null&quot;, nodeCode);</span>
<span class="nc" id="L146">			return false;</span>
		}
<span class="nc" id="L148">		return true;</span>
	}

	@Override
	public TreeNodeWrapper getShowableTree(Set&lt;String&gt; treeNodesToOpen, ITreeNode fullTree, Collection&lt;String&gt; groupCodes) throws ApsSystemException {
<span class="nc bnc" id="L153" title="All 4 branches missed.">		if (null == treeNodesToOpen || treeNodesToOpen.isEmpty()) {</span>
<span class="nc" id="L154">			_logger.warn(&quot;No selected nodes&quot;);</span>
<span class="nc" id="L155">			return this.buildWrapper(fullTree);</span>
		}
<span class="nc" id="L157">		TreeNodeWrapper root = null;</span>
		try {
<span class="nc" id="L159">			Set&lt;String&gt; nodesToShow = new HashSet&lt;&gt;();</span>
<span class="nc" id="L160">			this.buildCheckNodes(treeNodesToOpen, nodesToShow, groupCodes);</span>
<span class="nc" id="L161">			root = this.buildWrapper(fullTree);</span>
<span class="nc" id="L162">			root.setParent(root);</span>
<span class="nc" id="L163">			this.builShowableTree(root, fullTree, nodesToShow);</span>
<span class="nc" id="L164">		} catch (Throwable t) {</span>
<span class="nc" id="L165">			_logger.error(&quot;Error creating showable tree&quot;, t);</span>
<span class="nc" id="L166">			throw new ApsSystemException(&quot;Error creating showable tree&quot;, t);</span>
<span class="nc" id="L167">		}</span>
<span class="nc" id="L168">		return root;</span>
	}

	private void buildCheckNodes(Set&lt;String&gt; treeNodesToOpen, Set&lt;String&gt; nodesToShow, Collection&lt;String&gt; groupCodes) {
<span class="nc bnc" id="L172" title="All 2 branches missed.">		if (null == treeNodesToOpen) {</span>
<span class="nc" id="L173">			return;</span>
		}
<span class="nc" id="L175">		Iterator&lt;String&gt; iter = treeNodesToOpen.iterator();</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">		while (iter.hasNext()) {</span>
<span class="nc" id="L177">			String targetNode = (String) iter.next();</span>
<span class="nc" id="L178">			ITreeNode treeNode = this.getTreeNode(targetNode);</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">			if (null != treeNode) {</span>
<span class="nc" id="L180">				this.buildCheckNodes(treeNode, nodesToShow, groupCodes);</span>
			}
<span class="nc" id="L182">		}</span>
<span class="nc" id="L183">	}</span>

	protected void buildCheckNodes(ITreeNode treeNode, Set&lt;String&gt; nodesToShow, Collection&lt;String&gt; groupCodes) {
<span class="nc" id="L186">		nodesToShow.add(treeNode.getCode());</span>
<span class="nc" id="L187">		ITreeNode parent = this.getTreeNodeManager().getNode(treeNode.getParentCode());</span>
<span class="nc bnc" id="L188" title="All 4 branches missed.">		if (parent != null &amp;&amp; parent.getParentCode() != null</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">				&amp;&amp; !parent.getCode().equals(treeNode.getCode())) {</span>
<span class="nc" id="L190">			this.buildCheckNodes(parent, nodesToShow, groupCodes);</span>
		}
<span class="nc" id="L192">	}</span>

	private void builShowableTree(TreeNodeWrapper currentNode, ITreeNode currentTreeNode, Set&lt;String&gt; checkNodes) {
<span class="nc bnc" id="L195" title="All 2 branches missed.">		if (checkNodes.contains(currentNode.getCode())) {</span>
<span class="nc" id="L196">			currentNode.setOpen(true);</span>
<span class="nc" id="L197">			String[] children = currentTreeNode.getChildrenCodes();</span>
<span class="nc bnc" id="L198" title="All 2 branches missed.">			for (int i = 0; i &lt; children.length; i++) {</span>
<span class="nc" id="L199">				ITreeNode newCurrentTreeNode = this.getTreeNode(children[i]);</span>
<span class="nc" id="L200">				TreeNodeWrapper newNode = this.buildWrapper(newCurrentTreeNode);</span>
<span class="nc" id="L201">				newNode.setParent(currentNode);</span>
<span class="nc" id="L202">				newNode.setParentCode(currentNode.getCode());</span>
<span class="nc" id="L203">				currentNode.addChildCode(newNode.getCode());</span>
<span class="nc" id="L204">				currentNode.addChild(newNode);</span>
<span class="nc" id="L205">				this.builShowableTree(newNode, newCurrentTreeNode, checkNodes);</span>
			}
		}
<span class="nc" id="L208">	}</span>
    
	protected abstract boolean isNodeAllowed(String code, Collection&lt;String&gt; groupCodes);

	/**
	 * Default implementation of the method. Build a root node cloning the
	 * returned tree from the helper.
	 *
	 * @param groupCodes the groups codes
	 * @return the root node
	 * @throws ApsSystemException in caso of error
	 */
	@Override
	public ITreeNode getAllowedTreeRoot(Collection&lt;String&gt; groupCodes) throws ApsSystemException {
<span class="nc" id="L222">		ITreeNode currentRoot = this.getRoot();</span>
<span class="nc" id="L223">		TreeNodeWrapper root = this.buildWrapper(currentRoot);</span>
<span class="nc" id="L224">		this.addTreeWrapper(root, currentRoot);</span>
<span class="nc" id="L225">		return root;</span>
	}

	private void addTreeWrapper(TreeNodeWrapper currentNode, ITreeNode currentTreeNode) {
<span class="nc" id="L229">		String[] children = currentTreeNode.getChildrenCodes();</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">		for (int i = 0; i &lt; children.length; i++) {</span>
<span class="nc" id="L231">			ITreeNode newCurrentTreeNode = this.getTreeNode(children[i]);</span>
<span class="nc" id="L232">			TreeNodeWrapper newNode = this.buildWrapper(newCurrentTreeNode);</span>
<span class="nc" id="L233">			currentNode.addChildCode(newNode.getCode());</span>
<span class="nc" id="L234">			currentNode.addChild(newNode);</span>
<span class="nc" id="L235">			this.addTreeWrapper(newNode, newCurrentTreeNode);</span>
		}
<span class="nc" id="L237">	}</span>

	protected TreeNodeWrapper buildWrapper(ITreeNode treeNode) {
<span class="nc" id="L240">        ITreeNode parent = this.getTreeNodeManager().getNode(treeNode.getParentCode());</span>
<span class="nc" id="L241">		return new TreeNodeWrapper(treeNode, parent);</span>
	}
    
    protected abstract ITreeNodeManager getTreeNodeManager();

	/**
	 * Return the root node of the managed tree.
	 *
	 * @return The root node.
	 */
	protected abstract ITreeNode getRoot();

	/**
	 * Return a node of the managed tree.
	 *
	 * @param code The code of the node to return.
	 * @return The required node.
	 */
	protected abstract ITreeNode getTreeNode(String code);

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>